http://c.biancheng.net/view/1397.html

设计模式的概念：软件设计模式又称为设计模式，是一套被反复使用，多数人知晓的，经过分类编目的，代码设计经验的总结。它描述了在软件设计过程中
的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复
使用。其目的是为了提高代码的可重用性，代码的可读性，和代码的可靠性。
学习设计模式的意义：设计模式的本质是面向对象设计原则的实际运用，是对类的封装性，继承性和多态以及类的关联关系组合的充分理解。正确使用设计模式具有以下优点：
可以提高程序员的思维能力，编程能力和设计能力
使程序设计更加标准化，代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期
使设计的代码可重用性高，可读性强，可靠性高，灵活性好，可维护性强。

软件设计模式的基本要素：软件设计模式使人们更加方便的复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称，别名，动机，问题，解决方案，效果，结构
模式角色，合作关系，实现方法，适用性，已知应用，例程，模式扩展和相关模式等，其中关键的元素包含以下4个主要部分：
1.模式名称：每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题，特点，解决方案，功能和效果来命名。模式名称有助于我们理解和记忆该模式，也方便我们讨论自己的设计
2.问题：问题描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果。
3.解决方案：模式问题的解决方案包括设计的组成部分，它们之间的相互关系及各自的职责和协作方式。因为模式就像是一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计
或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合来解决这个问题。
4.效果：描述了模式的应用效果以及使用该模式权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性，扩充性，可移植性的影响，也考虑其实现问题。显试的列出这些效果。
对理解和评价这些模式有很大的帮助。


23种设计模式根据模式是用来完成什么工作来划分，这种方式可分为创建型模式，结构型模式，行为型模式3种
1.创建型模式：用于描述 怎么创建对象，它的作用主要特点是 将对象的创建与使用分离。主要有单例，原型，工厂方法，抽象工厂，建造者等5种创建型模式。
2.结构型模式：用于描述如何将类或者对象按照某种布局组成更大的结构，主要有代理，适配器，桥接，装饰，外观，享元，组合等7种结构型模式。
3.行为型模式： 用于描述类或对象怎样互相协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责，主要有模板方法，策略，命令，职责链，状态，观察者，中介者，迭代器，访问者，备忘录，解释器等11种行为型设计模式
创建型模式
1.单例模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其扩展是有限的多例模式，单例模式确保某一个类，只有一个实例，而且自行实例化，并向整个系统提供这个实例单例模式。单例模式只应在有
真正的 单一实例 的需求时才可使用
特点：
1.单例类只有一个实例对象
2.该单例对象必须由单例类自行创建
3.单例类对外提供一个访问该单例的全局访问点

2.原型模式：将一个对象作为一个原型，通过对其复制而克隆出多个和原型类似的新实例。通过给出一个原型对象来指明索要创建的对象类型，然后用复制这个原型对象的方法创建出更多同类型的对象，原始模型模式允许动态的增加或减少产品类
产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每个类都必须配备一个克隆方法。
特点：
要求对象实现一个可以克隆自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，
就可以通过这个方法来获取新的对象，而无须再通过new来创建

3.工厂方法模式： 定义一个用于创建产品的接口，由子类决定生产什么产品。核心工厂类不再负责所有产品的创建，而是将具体创建的工作交个子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节
定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中，这满足创建型模式中所要求的“创建与使用相分离”的特点
优点：
1.用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程
2.在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则
缺点：每增加一个产品，就要增加一个具体的产品类和一个对应的具体工厂类，这增加了系统的复杂度

4.抽象工厂模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。客户类和工厂类分开，消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品
优点：
1.用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程
2.在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则
3.可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行关联
4.当增加一个新的产品族时不需要修改原代码，满足开闭原则
缺点：
当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改

5.建造者模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成细节。
建造模式可以强制实行一种分步骤进行的建造过程。
优点：
1.各个具体的建造者相互独立，有利于系统的扩展
2.客户端不必知道产品内部组成的细节，便于控制细节风险

结构型模式
6.代理模式： 为某个对象提供一种代理以控制该对象的访问。即客户端通过代理间接的访问对象。从而限制，增强或修改该对象的一些特性。
由于某种原因需要给某对象提供一个代理以控制对该对象的访问，这时，访问对象不合适或者不能直接引用目标对象，代理对象作为访问对象和目标对象直接的中介

优点：
1.代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
2.代理对象可以扩展目标对象的功能
3.代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度
缺点：
1.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
2.增加了系统的复杂度

7.适配器模式：将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能在一起工作的那些类能一起工作。
优点：
1.客户端通过适配器可以透明地调用目标接口
2.复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类
3.将目标类和适配者解耦，解决了目标类和适配器接口不一致问题
4.在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能
缺点：
过多的使用适配器，会让系统非常凌乱，不宜整体进行把握.比如：明明调用的是接口A，其实内部被适配成了接口B，一个系统
如果太多的出现这种情况，无异于一场灾难。

8.桥接模式：将抽象与实现分离，使他们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度
优点：
1.由于抽象与实现分类，所以扩展能力强
2.其实现细节对客户透明
缺点：
由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计


9.装饰器模式： 动态的给对象增加一些职责，即增加其额外的功能。
优点：
1.采用装饰器模式扩展对象的功能比采用继承方式更加灵活
2.可以设计出多个不同的具体装饰类，创造出多个不同行为的组合
缺点：
装饰器模式增加了许多子类，如果过度的使用会使程序变得很复杂

10.外观模式：为多个复杂的子系统提供一个一致的接口，使得这些子系统更加容易被访问
优点：
1.降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响到调用它的客户类
2.对客户屏蔽了子系统组件，减少了客户处理对象的数目，并使得子系统使用起来更加容易
3.降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象

11.享元模式：运用共享技术来有效地支持大量细粒度对象的复用.它通过共享已经存在的对象来大幅度减少需要创建的对象数量，避免大量相似类的开销，从
而提高系统资源的利用率
优点：
相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力
缺点：
1.为了使对象可以共享，需要将一些不能共享的状态外部化，这增加程序的复杂性
2.读取享元模式的外部状态会使得运行时间稍微变长
享元模式的两种状态
1.内部状态：即不会随着环境的改变而改变的可共享部分
2.外部状态：指随着环境的改变而改变的不可共享部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。

12.组合模式：将对象组合成树状层次结构的模式，使用户对单个对象和组合对象具有一致的访问性。
优点：
1.组合模式使得客户端代码可以一致的处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码
2.更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源程序代码，满足开闭原则
缺点：
1.设计复杂，客户端需要花更多的时间清理类之间的层次关系
2.不容易限制容器中的构件

行为型模式
13.模板方法模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法的结构情况下重定义该算法的某些特定步骤
优点：
1.它封装了不变部分，扩展可变部分，它把认为式不变的部分的算法封装到分类中实现，而把可变部分算法由子类继承实现，以便于子类继续扩展
2.他在父类中提取了公共的部分代码，便于代码复用
3.部分方法由子类实现，因此子类可以通过扩展方式增加相应的功能，符合开闭原则
缺点：
1.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象
2.父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码的阅读难度

14.策略模式：定义了一系列算法，并将每个算法封装起来，使它们可以互相替换，且算法的改变不会影响使用算法的客户，它通过
对算法进行封装，把使用算法的责任和算法的实现分割开来，并委托给不同对象对这些算法进行管理
优点：
1.多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句
2.策略模式提供一系列的可供重用的算法族，恰当使用继承可以把算法族公共代码转移到父类里面，从而避免重复代码
3.策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的
4.策略模式提供了对开闭原则的完美支持，可以在不修改代码的情况下，灵活增加新算法
5.策略模式把算法的使用放到环境类中，而算法的实现转移到具体策略类中，实现了二者的分离
缺点：
1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类
2.策略模式会造成很多的策略类

15.命令模式：将一个请求封装为一个对象，使发出请求的职责和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将
命令对象进行存储，传递，调用，增加与管理
优点：
1.降低系统的耦合度，命令模式能将调用操作的对象与实现该操作的对象解耦
2.增加删除命令非常方便，采用命令模式增加与删除不会影响其他类，它满足开闭原则，对扩展比较灵活
3.可以实现宏命令，命令模式可以与组合模式结合，将多个命令装配成一个组合命令
4.方便实现撤销和恢复操作。
缺点：
可能会产生大量具体命令类，因为针对每一个具体操作都需要设计一个具体命令，这将增加系统的复杂性

16.职责链模式：为了避免请求发送者与多个请求处理者耦合在一起，把所有请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除去对象之间的藕合。
优点：
1.降低了对象之间的耦合度。该模式使得一个对象无须知道到底时哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息
2.增加了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则
3.增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调整好他们的次序，也可以动态的新增或者删除责任链
4.责任链简化了对象之间的连接。每个对象只需要保持一个指向其后继者的引用，不需要保持其他所有的处理者引用，者避免了使用众多的if或者if else 语句
5.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则
缺点：
1.不能保证每个请求一定被处理，由于一个请求没有明确的接收者，所有不能保证它一定会被处理，该请求可能一直传递到链的末端都得不到处理
2.对比较长的职责链，请求的处理可能会设计到多个处理对象，系统性能将会受到一定的影响
3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用

17.状态模式：对有状态的对象，把复杂的判断逻辑提取到不同的状态对象中，允许一个对象在其内部状态发生改变时改变其行为能力。
优点：
1.状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足”单一职责原则“
2.减少对象间的相互依赖，将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖
3.有利于程序的扩展，通过定义新的子类很容易的增加新的状态和转换
缺点：
1.状态模式的使用必然会增加系统的类和对象的个数
2.状态模式的结构与实现都比较复杂，如果使用不当会导致程序结构和代码的混乱

18.观察者模式：多个对象间存在一对多的依赖关系，当一个对象发生改变时，所有依赖于它的对象都得到通知，并被自动更新，从而影响其他对象的行为。
优点：
1.降低了目标与观察者之间的藕合关系，两者之间是抽象藕合关系
2.目标与观察者之间建立了一套触发机制
缺点：
1.目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用
2.当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率

19.中介者模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
优点：
1.降低了对象之间的藕合性，使得对象易于独立的被复用
2.将对象1对多的关联，转变为1对1的关联，提高系统灵活性，使得系统易于维护和扩展
缺点：
当同事类太多时，中介者的职责将会很大，它会变得复杂而庞大，以至于系统难以维护


20.迭代器模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
优点：
1.访问一个聚合对象的内容而无需暴露它的内部表示
2.遍历任务交由迭代器完成，这简化了聚合类
3.它支持以下不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历
4.增加新的聚合类和迭代器都很方便，不用修改原代码
5.封装性良好，为遍历不同的聚合结构提供一个统一的接口
缺点：
增加了类的个数，这在一定程度上增加了系统的复杂性

21.访问者模式：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，
为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。
优点:
1.扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
2.复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
3.灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
4.符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。
缺点:
1.增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
2.破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
3.违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

22.备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。
该模式又叫快照模式。
优点：
1.提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
2.实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
3.简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。
缺点：
资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。

23.解释器模式：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。
优点:
1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。
缺点:
1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。


开闭原则：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求
开闭原则的作用：开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性，具体来说，其作用如下
1.对软件测试的影响：软件遵从开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。
2.可以提高代码的可复用性：粒度越小，被复用的可能性就越大，在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性
3.可以提高软件的可维护性：遵从开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护

里氏替换原则：主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原则时继承复用的基础，
它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范
里氏替换原则的作用：子类可以扩展父类的功能，但是不能改变父类原有的功能
1.里氏替换原则是实现开闭原则的重要方式之一
2.它克服了继承中重写父类造成的可复用性变差的缺点
3.它是动作正确的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性

依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。其核心是：要面向接口编程，不要面向实现编程
由于软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定的多。这里的抽象指的是接口
或者抽象类，而细节指的是实现类。使用接口或者抽象类的目到是指定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交它们的实现类去完成。
依赖倒置的作用：
1.依赖倒置原则可以降低类间的耦合性
2.依赖倒置原则可以提高系统稳定性
3.依赖倒置原则可以减少并行开发引起的风险。
4.依赖倒置原则可以提高代码的可读性和可维护性

单一职责原则：这里的职责时指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
该原则提出对象不应该承担太多职责，如果一个对象承担太多的职责，至少存在以下两个缺点：
1.一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力
2.当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码浪费
单一职责的优点：核心就算控制类的粒度的大小，将对象解耦，提高其内聚性
1.降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多职责简单的多
2.提高类的可读性。复杂性降低，自然其可读性会提高
3.提高系统可维护性。可读性提高，那自然更容易维护了
4.变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响

接口隔离原则：一个类对另一个类的依赖应该建立在最小的接口上   含义：要为各个类建立他们需要的专用接口，而不要试图去建立一个很庞大的接口
供所有依赖它的类去调用。
接口隔离原则的优点：为了约束接口，降低类对接口的依赖性
1.将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性
2.接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性
3.如果接口粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务
，给整体项目带来无法预料的风险
4.使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对接口的定义。
5.能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码

迪米特法则：只和你的朋友交谈，不跟陌生人交谈 含义：如果两个软件实体无须之间通信，那么就不应该发生直接的相互调用，可以通过第三方转发该调用。其目的时降低类
之间的耦合度，提高模块的相对独立性。
迪米特法则的优点：要求限制软件实体之间通信的宽度和深度
1.降低类之间的耦合度，提高了模块的相对独立性
2.由于耦合度降低，从而提高了类的可复用率和系统的扩展性。

合成复用原则：要求软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现
合成复用原则的重要性：通常类的复用分为继承复用和合成复用两种，继承复用优点，简单易实现但是也存在以下缺点：
1.继承复用破坏了类的封装性，因为继承会将父类的实现细节暴漏给子类，父类对子类时透明的，所有这种复用又称为“白箱”复用
2.子类与父类的耦合度高，父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展和维护
3.它限制了复用的灵活性，从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化
采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有的功能，它有以下优点：
1.它维持了类的封装性，因为成分对象的内部细节时新对象看不见的，所以这种符合又称为“黑箱”复用
2.新旧类之间的耦合度低，这种复用依赖比较少，新对象存取成分对象的唯一方法时通过成分对象的接口
3.复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用成分对象类型形同的对象。

这7种设计原则是软件设计模式必须尽量遵循的原则，各种原则要求的侧重点不同。其中，开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭，
里氏替换原则告诉我们不要破坏继承体系，依赖倒置原则告诉我们要面向接口编程；单一职责原则告诉我们实现类要职责单一；接口隔离原则告诉我们在设计
接口的时候要精简单一；迪米特法则告诉我们要降低耦合度；合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。












































